<!DOCTYPE html>
<html>
	<head>
		<title>Block Rendering</title>
		<link rel="stylesheet" href="style.css">
		<link href='https://fonts.googleapis.com/css?family=Lato' rel='stylesheet'>
		<link href='https://fonts.googleapis.com/css?family=Francois%20One' rel='stylesheet'>
		<link href='https://fonts.googleapis.com/css?family=Lilita%20One' rel='stylesheet'>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
		
		<!-- BEGIN CDN SCRIPTS -->
		
		<script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/interactjs@1.9.15/dist/interact.min.js"></script>
		
		<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.53.2/codemirror.min.js"></script>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.53.2/codemirror.min.css" />
		<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.53.2/mode/javascript/javascript.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.53.2/addon/lint/json-lint.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.53.2/addon/edit/matchbrackets.min.js"></script>
		
		<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.53.2/addon/fold/brace-fold.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.53.2/addon/fold/foldcode.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.53.2/addon/fold/foldgutter.min.js"></script>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.53.2/addon/fold/foldgutter.min.css" />
				
		<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.53.2/addon/lint/json-lint.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.53.2/addon/lint/lint.min.js"></script>
		<script src="https://unpkg.com/jsonlint@1.6.3/web/jsonlint.js"></script>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.53.2/addon/lint/lint.min.css" />
		
		<!-- END CDN SCRIPTS -->
		
		<script src="../main.js"></script>
		<script src="blockrender.js"></script>
		
		<link rel="icon" type="image/png" sizes="32x32" href="/hs-tools/icons/favicon-32x32.png">
		<link rel="icon" type="image/png" href="https://aws1.discourse-cdn.com/gethopscotch/original/3X/3/8/3836ff26c18740a553e96462dc1ece3d8e7f4869.png">
		
		<link rel="apple-touch-icon" sizes="180x180" href="/hs-tools/icons/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="/hs-tools/icons/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/hs-tools/icons/favicon-16x16.png">
		<link rel="manifest" href="/hs-tools/icons/site.webmanifest">
		<link rel="mask-icon" href="/hs-tools/icons/safari-pinned-tab.svg" color="#5bbad5">
		<link rel="shortcut icon" href="/hs-tools/icons/favicon.ico">
		<meta name="apple-mobile-web-app-title" content="Hopscotch Tools">
		<meta name="application-name" content="Hopscotch Tools">
		<meta name="msapplication-TileColor" content="#da532c">
		<meta name="msapplication-config" content="/hs-tools/icons/browserconfig.xml">
		<meta name="theme-color" content="#ffffff">
		
		<meta name="description" content="This page can render all of the code inside of a Hopscotch Project."/>
		<meta name="keywords" content="build, mod, text, project, hopscotch"/>
		<meta property="og:title" content="Hopscotch Block Rendering">
		<meta property="og:description" content="This page can render all of the code inside of a Hopscotch Project.">
		<meta property="og:image" content="/hs-tools/images/ability-bars.png">
		
		<style>
			html, body {
				font-family: Lato;
				-webkit-overflow-scrolling: touch;
				width: 100%;
				height: 100%;
			}
			@supports not (-webkit-touch-callout: none) {
				/* CSS for other than iOS devices */
				.bl-container::-webkit-scrollbar {
					width: 14px;
					z-index:1001;
				}
				.bl-container::-webkit-scrollbar-track {
					background-color: #eee;
					border-radius: 0;
				}
				.bl-container::-webkit-scrollbar-thumb {
					background-color: rgba(100,100,100,0.8); /*#e6d700;*/
					border-radius: 10px;
					opacity: 0.75;
				}
				.bl-container::-webkit-scrollbar-thumb:active {
				  background-color: rgba(100,100,100,0.7); /*#e6cf00;*/
					opacity:1;
				}
				.bl-container::-webkit-scrollbar-corner {
				  background-color: #eee;
				}
			}
		</style>
	</head>
	<body>
		<button onclick="theme()" id="themebtn" style="right:0;"><i class="fa fa-fw fa-moon-o"> </i></button>
		<div id="blocks-container-resizer" class="resize-drag">
			<div class="drag-handle">Block Rendering: Loading...</div>
			<div id="blocks-container" class="bl-container" style="padding: 36px 8px;"></div>
			<div class="resizer"></div>
		</div>
		<div class="edit-box">
			<textarea></textarea>
			<div class="block-preview"></div>
			<span class="controls"><button onclick="editclose()" title="Close without saving (Esc)"><i class="fa fa-close"></i> CLOSE </button><button onclick="editsave()" title="Close and save changes (Ctrl+Enter)"><i class="fa fa-check"></i> SAVE </button></span>
			<span class="lower-controls"><button id="focus-btn" onclick="editfocus()" title="" class=""><i class="fa fa-eye"></i> FOCUS VIEW </button><button onclick="editdelete()" title="Delete Block" class="danger"><i class="fa fa-trash"></i> DELETE </button></span>
			</div>
		</div>
		<script src="../sidenav.min.js"></script>
		<script src="editor.js"></script>
		<script>
			var hsProject, projectDict = {};
			
			var COUNT = 0;
			
			function addBlockFunctions(parent) {
				parent.querySelectorAll(".editbtn").forEach((elm)=>{
					elm.onclick = function(e){
						activeEditBlock = e.target.parentNode.parentNode;
						//document.querySelector(".edit-box textarea").value = JSON.stringify(JSON.parse(activeEditBlock.getAttribute("data")),null,"\t");
						document.querySelector(".edit-box").style.display = "block";
						var blockData = JSON.parse(activeEditBlock.getAttribute("data"));
						(jsonToHtml(blockData).focusType != "blocks" || blockData.type == 123) ? document.getElementById("focus-btn").removeAttribute("disabled") : document.getElementById("focus-btn").setAttribute("disabled","");
						editor.getDoc().setValue(JSON.stringify(JSON.parse(activeEditBlock.getAttribute("data")),null,"\t"));
						editor.clearHistory();
					}
				});
				parent.querySelectorAll("*:not(.disabled) > bl .openbtn").forEach((elm)=>{
					elm.onclick = function(e){
						var parentBlock = e.target.parentNode.parentNode;
						var hasDomInside = Boolean(parentBlock.childElementCount>1/*&&parentBlock.querySelector("div.collapsible").innerHTML.match(/"/)*/);
						if (hasDomInside) {
							parentBlock.classList.toggle("collapsible-container");
							parentBlock.querySelectorAll("div.collapsible").remove();
						} else {
							//If there is no child container, refresh the block and load what's inside.
							activeEditBlock = parentBlock;
							editor.getDoc().setValue(activeEditBlock.getAttribute("data"));
							editsave(true);
						}
					}
				});
				var list = parent.querySelectorAll(".collapsible");
				list.forEach((l)=>{
					new Sortable(l, {
						group: l.parentNode.getAttribute("data-group"),
						ghostClass: 'invis',
						dragClass: 'dragged',
						fallbackTolerance: 5,
						forceFallback: true,
						delayOnTouchOnly: true,
						animation: 150,
						handle: '.handle',
						fallbackOnBody: true,
						swapThreshold: 0.65,
						multiDrag: true,
						selectedClass: 'selected',
						onEnd: function(e){
							updatescript(e.from), updatescript(e.to);
						}
					});
				});
			}
			
			function replaceRender(data, tct, desc) {
				if (data == -1) {
					desc = "Entire Project";
					if (hsProject.scenes) {
						data = hsProject.scenes, tct = "scenes";
					} else {
						data = hsProject.objects||[], tct = "objects";
					}
				}
				document.getElementById("blocks-container-resizer").innerHTML = '<div class="drag-handle">Block Rendering: ' + desc + (desc!="Entire Project"&&tct?' <a title="See Entire Project" href="javascript:replaceRender(-1)">&ic; <i class="fa fa-list-alt"></i></a>':'')+'</div><div id="blocks-container" class="bl-container" style="padding: 36px 8px;" data-group="'+tct+'"></div><div class="resizer"></div>';
				//Data = Data Array, Top Container Type (e.g. Rules, Objects)
				data.forEach(function(item) {
					var blockElm = document.createElement("div");
					var blockInfo = jsonToHtml(item, undefined, (item.type==123||typeof item == "string"||item.xPosition!=null||(item.objects&&data.length>1)));
					blockElm.setAttribute("class", blockInfo.classList);
					blockElm.setAttribute("data", blockInfo.data);
					if (blockInfo.id) blockElm.setAttribute("data-id", blockInfo.id);
					blockElm.setAttribute("data-group", blockInfo.sortGroup);
					blockElm.innerHTML = blockInfo.innerHTML;
					document.getElementById("blocks-container").appendChild(blockElm);
				});
				
				x = new Sortable(document.querySelector(".bl-container"), {
					group: tct,
					ghostClass: 'invis', dragClass: 'dragged', fallbackTolerance: 5,
					forceFallback: true, delayOnTouchOnly: true, animation: 150,
					handle: '.handle', multiDrag: true, selectedClass: 'selected',
					onEnd: function(e){
						updatescript(e.from), updatescript(e.to);
					}
				});
				
				document.querySelector(".bl-container").setAttribute("data-group", tct);
				
				addBlockFunctions(document);
			}
			setTimeout(function(){
				var url = new URL(location.href);
				if (localStorage.getItem("projectFromStorage") &&  url.searchParams.get("play") == "1") {
					hsProject = JSON.parse(localStorage.getItem("projectFromStorage"));
					formatProject(hsProject);
					replaceRender(-1); //-1 means top (entire project)
				} else {
					req_id = (new URL(location.href)).searchParams.get("id") || localStorage.getItem("defaultProjUrl")?localStorage.getItem("defaultProjUrl"):(prompt("Project UUID","test")||"").replace(/.*\//,"");
					req_id = (new URL(location.href)).searchParams.get("id") || req_id;
					if (req_id) XHR.get(/*"https://c.gethopscotch.com/api/v1/projects/test"*/"https://api.allorigins.win/raw?url=https://c.gethopscotch.com/api/v1/projects/"+req_id, function(r){
						try {
							hsProject = JSON.parse(r);
						} catch (E) {
							return alert("Invalid Response");
						}
						formatProject(hsProject);
						replaceRender(-1); //-1 means top (entire project)
					},false);//true);
					else {
						replaceRender([],"","No project loaded");
					}
				}
			}, 400);
			
			var activeEditBlock;
			function editclose() {
				document.querySelector(".edit-box").style.display = "none";
				activeEditBlock = null;
			}
			function editsave(forceOpen) {
				forceOpen = forceOpen||false; // swap state?
				var savetext = editor.getValue()/*document.querySelector(".edit-box textarea").value*/||'{}';
				try {
					//Valid Block
					var info = jsonToHtml(JSON.parse(savetext), undefined, !(forceOpen||activeEditBlock.classList.contains("collapsible-container")));
					//Open the block if forced to open or is already open
					activeEditBlock.innerHTML = info.innerHTML;
					activeEditBlock.setAttribute("class", info.classList);
					activeEditBlock.setAttribute("data", info.data);
					if (info.id) activeEditBlock.setAttribute("data-id", info.id);
					activeEditBlock.setAttribute("data-group", info.sortGroup);
					
					if (!activeEditBlock.innerHTML) activeEditBlock.parentNode.removeChild(activeEditBlock);
					if (document.querySelector(".edit-box").style.display == "block") updatescript(activeEditBlock, true), updatescript(activeEditBlock.parentNode);
					document.querySelector(".edit-box").style.display = "none";
					addBlockFunctions(activeEditBlock);
					activeEditBlock = null;
				} catch (E) {
					console.error(E);
					//Valid JSON but invalid block, can indicate delete
					try {
						JSON.parse(savetext);
						document.querySelector(".edit-box").style.display = "none";
						activeEditBlock = null;
					} catch (E) {
						alert("Invalid JSON");
					}
				}
			}
			function editdelete() {
				editor.getDoc().setValue('{}');
				if (activeEditBlock) editsave();
			}
			function editfocus() {
				var blockData = JSON.parse(activeEditBlock.getAttribute("data"));
				document.getElementById("blocks-container-resizer").setAttribute("data", JSON.stringify(blockData));
				console.log("blocks", projectDict.objects[blockData.objectID||"idk"]);
				if (blockData.objects) replaceRender(blockData.objects, "objects", "Objects in \u201C" + blockData.name + "\u201D");
				else if (blockData.rules) replaceRender(blockData.rules, "rules", "Rules of \u201C" + blockData.name + "\u201D");
				else if (blockData.abilityID) replaceRender(Object.keys(projectDict.abilities[blockData.abilityID].blocks).repeatEach(b=>{return projectDict.abilities[blockData.abilityID].blocks[b]}), "blocks", "When \u201C" + (blockLabels[(blockData.parameters[0].datum||{}).type][1]||"").replace(/\u2063\s|\s\u2063/g,"") + "\u201D for \u201C" + (blockData.objectID?projectDict.objects[blockData.objectID||{}].name:JSON.parse(activeEditBlock.parentNode.parentNode.getAttribute("data")).name) + "\u201D");
				else if (blockData.controlScript) replaceRender(Object.keys(projectDict.abilities[blockData.controlScript.abilityID].blocks).repeatEach(b=>{return projectDict.abilities[blockData.controlScript.abilityID].blocks[b]}), "blocks", "Blocks in \u201C" + blockData.description + "\u201D");
				//console.log(activeEditBlock,jsonToHtml(blockData).focusType);
				document.getElementById("blocks-container").setAttribute("data", JSON.stringify(blockData));
				editclose();
			}
			document.body.onkeydown = function(e) {
				if (!activeEditBlock) return;
				if (e.keyCode == 27) editclose();
				if ((e.ctrlKey||e.metaKey)&&e.keyCode == 13) editsave();
			}
			function writedata(type, web_id, newdata) {
				switch (type) {
					case "project":
						if (newdata[0].objects) {
							//Write to scenes (newer projects)
							hsProject.scenes = newdata;
						} else {
							//Write to objects (older projects)
							hsProject.objects = newdata;
						}
						break;
					case "scene":
						projectDict.scenes[web_id] = newdata;
						for (i = 0; i < (hsProject.scenes||[]).length; i++){
							if (hsProject.scenes[i].web_id == web_id) {
								hsProject.scenes[i] = newdata;
								hsProject.scenes[i].web_id = web_id;
							}
						}
						break;
					case "object":
						projectDict.objects[web_id] = newdata;
						//(hsProject.objects||[]).forEach(o=>{
						for (i = 0; i < (hsProject.objects||[]).length; i++) {
							if (hsProject.objects[i].objectID == web_id) hsProject.objects[i] = newdata;
						};
						break;
					case "crule": //incomplete
						projectDict.customRules[web_id] = newdata;
						//(hsProject.customRules||[]).forEach(r=>{
						for (i = 0; i < (hsProject.customRules||[]).length; i++) {
							if (hsProject.customRules[i].id == web_id) hsProject.customRules[i] = newdata;
						};
						break;
					case "rule":
						projectDict.rules[web_id] = newdata;
						//(hsProject.rules||[]).forEach(r=>{
						for (i = 0; i < (hsProject.rules||[]).length; i++) {
							if (hsProject.rules[i].id == web_id) hsProject.rules[i] = newdata;
						};
						break;
					case "ability": //Input the whole new ability
						projectDict.abilities[web_id] = projectDict.abilities[web_id]||{},
							projectDict.abilities[web_id].blocks = {},
							projectDict.abilities[web_id].name = newdata.name,
							projectDict.abilities[web_id].createdAt = newdata.createdAt,
							projectDict.abilities[web_id].abilityID = newdata.abilityID;
						for (i = 0; i < (newdata.blocks||[]).length; i++) {
							newblock = newdata.blocks[i];
							newblock.web_id = web_id + "_b" + i;
							projectDict.abilities[web_id].blocks[newblock.web_id] = newblock;
						}
						for (i = 0; i < (hsProject.abilities||[]).length; i++) {
							var a = hsProject.abilities[i];
							if (hsProject.abilities[i].abilityID == web_id) {
								for (j = 0; j < (newdata.blocks||[]).length; j++) {
									var b = newdata.blocks[j];
									b.web_id = web_id + "_b" + j;
								}
								hsProject.abilities[i] = newdata;
								hsProject.abilities[i].blocks = newdata.blocks;
							}
						};
						break;
					//There is no need to update a block because it updates the ability regardless
				}
				var url = new URL(location.href);
				if (url.searchParams.get("play") == "1") {
					console.log("%cProject Instance Saved","color:lime;font-weight:600;");
					localStorage.setItem("projectFromStorage", JSON.stringify(hsProject));
				}
			}
			function updatescript(container, isBlock) {
				isBlock = isBlock||false;
				var cp = (!isBlock) ? container.parentNode : container;
				var scData = JSON.parse(cp.getAttribute("data"));
				scType = !scData ? "project" : (scData.objects?"scene":(scData.xPosition!=undefined?"object":(scData.rules?"crule":(scData.abilityID?"rule":"ability"))));
				scId = (!scData ? "none" : scData.web_id||scData.id||scData.abilityID||scData.objectID||cp.getAttribute("data-id"));
				if (scData && (scData.controlScript || scData.controlFalseScript)) scId = (container.previousElementSibling && container.previousElementSibling.classList.contains("collapsible")) ? scData.controlFalseScript.abilityID : scData.controlScript.abilityID
				var newdata = {};
				if (isBlock && scType == "ability") return;
				switch (scType) {
					case "ability": //Change the parent ability
						newdata = {
							"abilityID": scId,
							"blocks": container.children.repeatEach(c=>{
								return JSON.parse(c.getAttribute("data"));
							}),
							"createdAt": (projectDict.abilities[scId]||{createdAt:newestCreateDate}).createdAt
						};
						if (scData.name) newdata.name = scData.name;
						break;
					case "rule":
						if (isBlock) {
							//Change the rule block itself
							newdata = scData;
							scId = scData.id;
						} else {
							//Change the ability within the rule
							newdata = {
								"abilityID": scData.abilityID,
								"blocks": container.children.repeatEach(c=>{
									return JSON.parse(c.getAttribute("data"));
								}),
								"createdAt": (projectDict.abilities[scData.abilityID]||{createdAt:newestCreateDate}).createdAt
							};
							if (scData.name) newdata.name = projectDict.abilities[scData.abilityID].name;
							scType = "ability";
							scId = scData.abilityID;
						}
						break;
					case "crule": //Change the rules within the custom rule
					case "object": //Change the rules within the object
						newdata = scData;
						newdata.rules = container.children.repeatEach(c=>{
							return JSON.parse(c.getAttribute("data")||'{}').id;
						});
						scId = scData.id||scData.objectID;
						break;
					case "scene": //Change the objects in the scene
						newdata = scData;
						if (!isBlock) newdata.objects = container.children.repeatEach(c=>{
							return JSON.parse(c.getAttribute("data")).objectID;
						});
						break;
					case "project":
						newdata = document.querySelectorAll(".bl-container > div").repeatEach(c=>{
							return JSON.parse(c.getAttribute("data"));
						});
						break;
				}
				if (!(scData||{}).ruleBlockType && scType != "project") cp.setAttribute("data", JSON.stringify(newdata));
				writedata(scType, scId, newdata);
			}
			/* CodeMirror */
			var editor = CodeMirror.fromTextArea(document.querySelector("textarea"), {
				matchBrackets: true,
				autoCloseBrackets: true,
				mode: "application/ld+json",
				foldGutter: true,
				lint: true,
				gutters: ["CodeMirror-lint-markers","CodeMirror-linenumbers", "CodeMirror-foldgutter"],
				lineWrapping: false,
				value: '{}',
				lineNumbers: true,
				indentWithTabs: true,
				tabSize: 2
			});
			editor.on("change",function(e){
				try {
					JSON.parse(editor.getValue());
					//console.log("Successful JSON Parse")
					document.querySelector(".edit-box .block-preview").innerHTML = jsonToHtml(JSON.parse(editor.getValue())).innerHTML.replace(/<b class="editbtn"><\/b>/g,"").replace(/ class="(handle|openbtn)/g,' style="cursor:unset;opacity:1;" class="'+"$1");
				} catch (E) {}
			});
			/* Interact JS */
			interact('.resize-drag').resizable({
				//Resize from all edges and corners
				edges: { 
					right: ".resizer",
					bottom: ".resizer"
				},
				listeners: {
					move (event) {
						var target = event.target;
						var x = (parseFloat(target.getAttribute('data-x')) || 0);
						var y = (parseFloat(target.getAttribute('data-y')) || 0);
						//Update the element's style
						target.style.width = event.rect.width + 'px';
						target.style.height = event.rect.height + 'px';
						//Translate when resizing from top or left edges
						x += event.deltaRect.left, y += event.deltaRect.top;
						target.style.webkitTransform = target.style.transform = 'translate(' + x + 'px,' + y + 'px)';
					}
				},
				modifiers: [
					//Keep the edges inside the parent
					interact.modifiers.restrictEdges({
						outer: 'parent'
					}),
					//Minimum size
					interact.modifiers.restrictSize({
					min: { width: 300, height: 150 }
					})
				],
				inertia: true
			}).draggable({
				allowFrom: 'div.drag-handle',
				//Enable inertial throwing
				inertia: true,
				//Keep the element within the area of it's parent
				modifiers: [
					interact.modifiers.restrictRect({
					restriction: 'parent',
					endOnly: true
					})
				],
				//Enable autoScroll
				autoScroll: true,

				listeners: {
					//Call this function on every dragmove event
					start (event) {
						var target = event.target;
						//Set Z Index of the elements
						for (i = 0; i < draggables.length; i++) {
							if (Number(draggables[i].style.zIndex) > Number(target.style.zIndex)) draggables[i].style.zIndex = draggables[i].style.zIndex - 1;
						};
						target.style.zIndex = document.querySelectorAll(".resize-drag").length;
					},
					move (event) {
						var target = event.target;
						//Keep the dragged position in the data-x/data-y attributes
						var x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
						var y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
						
						//Translate the element
						target.style.webkitTransform = target.style.transform = 'translate(' + x + 'px, ' + y + 'px)';// update the posiion attributes
						target.setAttribute('data-x', x); target.setAttribute('data-y', y);
					}
				}
			});
			//Z Index of draggable elements
			var draggables = document.querySelectorAll(".resize-drag");
			for (i = 0; i < draggables.length; i++) {
				draggables[i].style.zIndex = i;
			};
		</script>
	</body>
</html>